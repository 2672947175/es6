let sta = { a: 'aa', b: '11', c: 'fdf' }
let aa = { c: '世纪东方得分' }
let ab = { d: '都快废了' }
let obj = Object.assign(sta, aa, ab)
obj
/*

    深拷贝和浅拷贝的区别

    1.浅拷贝： 将原对象或原数组的引用直接赋给新对象，
    新数组，新对象／数组只是原对象的一个引用
    2.深拷贝： 创建一个新的对象和数组，将原对象的各项属性的“值”
    （数组的所有元素）拷贝过来，是“值”而不是“引用”

    在js中，数据类型分为两种，基本类型和引用类型。基本类型指的是简单的数据段，
    而引用类型指的是那些可能由多个值构成的对象。
    js中有五种基本数据类型number,string,boolean,null,undefined，
    他们的值被以键值对的形式保存在栈中。

    引用类型只有object一种。
    但js中除了基本数据类型，万物皆对象，数组，函数，
    对象都是object类型，甚至null也被认为是一个空对象，
    使用typeof检测时返回object。与基本类型不同的是，
    引用类型的值被保存在堆内存中，对象的引用被保存在栈内存中，
    而且我们不可以直接访问堆内存，只能访问栈内存。
    所以我们操作引用类型时实际操作的是对象的引用。

    现在我们来看文章开头那句话，浅拷贝是拷贝了对象的引用，
    所以基本数据类型是不存在深浅拷贝的。当 a=1，b=a时，
    栈内存会新开辟一个内存，例如这样：

    深拷贝与浅拷贝出现的根源就在于引用数据类型。
    当我们定义a=[0,1,2,3,4]，b=a时，其实复制的是a的引用地址，
    而并非堆里面的值。因为指向了相同的地址，
    所以当我们更改a时b会改变，更改b时a也会改变，这就是浅拷贝。

    但很多时候我们并不希望a和b直接互相影响，这时就需要想下图这样，
    单独为b也开辟一块堆内存，这就用到了深拷贝。



二.深拷贝的实现
    深拷贝是针对引用类型的，在进行深拷贝之前，
    我们应该先知道js中有哪些引用类型，
    js中引用类型有六种：object，array，date，regexp，function，err。
    下面的两种方法只能实现object，array的深拷贝。

    1. 迭代递归法
    for...in...法
    对对象进行迭代操作，对它的每个值进行递归深拷贝。

*/